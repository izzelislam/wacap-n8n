"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
const baileys_1 = __importStar(require("@whiskeysockets/baileys"));
const pino_1 = __importDefault(require("pino"));
const qrcode_terminal_1 = __importDefault(require("qrcode-terminal"));
const path_1 = require("path");
const fs_1 = require("fs");
const types_1 = require("../types");
const events_1 = require("../events");
/**
 * WhatsApp session manager
 * Handles individual WhatsApp connections
 */
class Session {
    sessionId;
    config;
    socket = null;
    eventManager;
    storageAdapter;
    sessionPath;
    isConnecting = false;
    shouldReconnect = true;
    retryCount = 0;
    constructor(sessionId, config, storageAdapter) {
        this.sessionId = sessionId;
        this.storageAdapter = storageAdapter;
        this.eventManager = new events_1.EventManager(sessionId);
        // Set default config values
        this.config = {
            sessionsPath: config.sessionsPath || './sessions',
            storageAdapter: config.storageAdapter || 'sqlite',
            debug: config.debug || false,
            logger: config.logger || { level: 'warn' },
            prismaClient: config.prismaClient,
            autoDisplayQR: config.autoDisplayQR !== false,
            browser: config.browser || ['Wacap', 'Chrome', '1.0.0'],
            connectionTimeout: config.connectionTimeout || 60000,
            maxRetries: config.maxRetries || 5,
        };
        this.sessionPath = (0, path_1.join)(this.config.sessionsPath, this.sessionId);
        // Ensure session directory exists
        if (!(0, fs_1.existsSync)(this.sessionPath)) {
            (0, fs_1.mkdirSync)(this.sessionPath, { recursive: true });
        }
    }
    /**
     * Start the WhatsApp session
     */
    async start() {
        if (this.isConnecting || this.socket) {
            throw new Error(`Session ${this.sessionId} is already active or connecting`);
        }
        this.isConnecting = true;
        this.shouldReconnect = true;
        this.retryCount = 0;
        try {
            await this.connect();
        }
        catch (error) {
            this.isConnecting = false;
            throw error;
        }
    }
    /**
     * Connect to WhatsApp
     */
    async connect() {
        const logger = (0, pino_1.default)({
            level: this.config.logger.level,
        });
        // Load auth state
        const { state, saveCreds } = await (0, baileys_1.useMultiFileAuthState)(this.sessionPath);
        // Get latest version
        const { version } = await (0, baileys_1.fetchLatestBaileysVersion)();
        // Create socket
        this.socket = (0, baileys_1.default)({
            version,
            logger,
            printQRInTerminal: false, // We handle QR display ourselves
            auth: {
                creds: state.creds,
                keys: (0, baileys_1.makeCacheableSignalKeyStore)(state.keys, logger),
            },
            browser: this.config.browser,
            generateHighQualityLinkPreview: true,
            syncFullHistory: false,
            shouldIgnoreJid: (jid) => jid === 'status@broadcast',
        });
        this.socket.sessionId = this.sessionId;
        // Setup event handlers
        this.setupEventHandlers(saveCreds);
        this.isConnecting = false;
        // Emit session start event
        this.eventManager.emit(types_1.WacapEventType.SESSION_START, {
            sessionId: this.sessionId,
            timestamp: new Date(),
        });
    }
    /**
     * Setup event handlers for the socket
     */
    setupEventHandlers(saveCreds) {
        if (!this.socket)
            return;
        // Connection updates
        this.socket.ev.on('connection.update', async (update) => {
            const { connection, lastDisconnect, qr } = update;
            // Emit connection update event
            this.eventManager.emit(types_1.WacapEventType.CONNECTION_UPDATE, {
                sessionId: this.sessionId,
                timestamp: new Date(),
                state: update,
                qr,
            });
            // Handle QR code
            if (qr) {
                if (this.config.autoDisplayQR) {
                    console.log(`\n[${this.sessionId}] Scan this QR code to login:\n`);
                    qrcode_terminal_1.default.generate(qr, { small: true });
                }
                this.eventManager.emit(types_1.WacapEventType.QR_CODE, {
                    sessionId: this.sessionId,
                    timestamp: new Date(),
                    state: update,
                    qr,
                });
            }
            // Handle connection open
            if (connection === 'open') {
                console.log(`[${this.sessionId}] Connection opened successfully`);
                this.retryCount = 0;
                this.eventManager.emit(types_1.WacapEventType.CONNECTION_OPEN, {
                    sessionId: this.sessionId,
                    timestamp: new Date(),
                    state: update,
                });
            }
            // Handle disconnection
            if (connection === 'close') {
                const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== baileys_1.DisconnectReason.loggedOut;
                console.log(`[${this.sessionId}] Connection closed. Reconnecting: ${shouldReconnect}`);
                this.eventManager.emit(types_1.WacapEventType.CONNECTION_CLOSE, {
                    sessionId: this.sessionId,
                    timestamp: new Date(),
                    state: update,
                    error: lastDisconnect?.error,
                });
                if (shouldReconnect && this.shouldReconnect) {
                    if (this.retryCount < this.config.maxRetries) {
                        this.retryCount++;
                        console.log(`[${this.sessionId}] Reconnecting... (Attempt ${this.retryCount}/${this.config.maxRetries})`);
                        await (0, baileys_1.delay)(3000); // Wait 3 seconds before reconnecting
                        await this.connect();
                    }
                    else {
                        console.error(`[${this.sessionId}] Max retry attempts reached. Stopping session.`);
                        this.eventManager.emit(types_1.WacapEventType.SESSION_ERROR, {
                            sessionId: this.sessionId,
                            timestamp: new Date(),
                            error: new Error('Max retry attempts reached'),
                        });
                    }
                }
            }
        });
        // Credentials update
        this.socket.ev.on('creds.update', saveCreds);
        // Messages
        this.socket.ev.on('messages.upsert', async ({ messages, type }) => {
            for (const message of messages) {
                // Save message to storage
                await this.storageAdapter.saveMessage(this.sessionId, message);
                // Emit message event
                const eventData = {
                    sessionId: this.sessionId,
                    timestamp: new Date(),
                    message,
                    isFromMe: message.key.fromMe,
                    messageType: Object.keys(message.message || {})[0],
                    body: this.getMessageBody(message),
                    from: message.key.remoteJid,
                };
                if (message.key.fromMe) {
                    this.eventManager.emit(types_1.WacapEventType.MESSAGE_SENT, eventData);
                }
                else {
                    this.eventManager.emit(types_1.WacapEventType.MESSAGE_RECEIVED, eventData);
                }
            }
        });
        // Message updates
        this.socket.ev.on('messages.update', async (updates) => {
            for (const update of updates) {
                this.eventManager.emit(types_1.WacapEventType.MESSAGE_UPDATE, {
                    sessionId: this.sessionId,
                    timestamp: new Date(),
                    message: update,
                });
            }
        });
        // Message deletes
        this.socket.ev.on('messages.delete', async (item) => {
            this.eventManager.emit(types_1.WacapEventType.MESSAGE_DELETE, {
                sessionId: this.sessionId,
                timestamp: new Date(),
            });
        });
        // Contacts
        this.socket.ev.on('contacts.update', async (updates) => {
            for (const contact of updates) {
                if (contact.id) {
                    await this.storageAdapter.saveContact(this.sessionId, contact);
                }
            }
            this.eventManager.emit(types_1.WacapEventType.CONTACT_UPDATE, {
                sessionId: this.sessionId,
                timestamp: new Date(),
            });
        });
        // Chats
        this.socket.ev.on('chats.upsert', async (chats) => {
            for (const chat of chats) {
                await this.storageAdapter.saveChat(this.sessionId, chat);
            }
            this.eventManager.emit(types_1.WacapEventType.CHAT_UPDATE, {
                sessionId: this.sessionId,
                timestamp: new Date(),
            });
        });
        // Groups
        this.socket.ev.on('groups.update', async (updates) => {
            this.eventManager.emit(types_1.WacapEventType.GROUP_UPDATE, {
                sessionId: this.sessionId,
                timestamp: new Date(),
            });
        });
        // Group participants
        this.socket.ev.on('group-participants.update', async (update) => {
            this.eventManager.emit(types_1.WacapEventType.GROUP_PARTICIPANTS_UPDATE, {
                sessionId: this.sessionId,
                timestamp: new Date(),
                groupId: update.id,
                participants: update.participants.map(p => typeof p === 'string' ? p : p.id),
                action: update.action,
                author: update.author,
            });
        });
        // Presence
        this.socket.ev.on('presence.update', async (update) => {
            this.eventManager.emit(types_1.WacapEventType.PRESENCE_UPDATE, {
                sessionId: this.sessionId,
                timestamp: new Date(),
                jid: update.id,
                presences: update.presences,
            });
        });
        // Calls
        this.socket.ev.on('call', async (calls) => {
            this.eventManager.emit(types_1.WacapEventType.CALL, {
                sessionId: this.sessionId,
                timestamp: new Date(),
            });
        });
    }
    /**
     * Extract message body text
     */
    getMessageBody(message) {
        const messageContent = message.message;
        if (!messageContent)
            return undefined;
        return (messageContent.conversation ||
            messageContent.extendedTextMessage?.text ||
            messageContent.imageMessage?.caption ||
            messageContent.videoMessage?.caption ||
            messageContent.documentMessage?.caption ||
            undefined);
    }
    /**
     * Stop the session
     */
    async stop() {
        this.shouldReconnect = false;
        if (this.socket) {
            await this.socket.logout();
            this.socket = null;
        }
        this.eventManager.emit(types_1.WacapEventType.SESSION_STOP, {
            sessionId: this.sessionId,
            timestamp: new Date(),
        });
    }
    /**
     * Get session info
     */
    getInfo() {
        const connectionState = this.socket?.user
            ? { connection: 'open' }
            : { connection: 'close' };
        return {
            sessionId: this.sessionId,
            isActive: !!this.socket,
            connectionState: connectionState,
            phoneNumber: this.socket?.user?.id?.split(':')[0],
            userName: this.socket?.user?.name,
            startedAt: undefined, // Could track this
            lastActivityAt: new Date(),
        };
    }
    /**
     * Get event manager for registering event handlers
     */
    getEventManager() {
        return this.eventManager;
    }
    /**
     * Get the socket instance
     */
    getSocket() {
        return this.socket;
    }
    /**
     * Check if session is active
     */
    isActive() {
        return !!this.socket;
    }
}
exports.Session = Session;
//# sourceMappingURL=session.js.map