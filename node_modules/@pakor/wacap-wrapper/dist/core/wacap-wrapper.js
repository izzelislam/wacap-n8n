"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WacapWrapper = void 0;
const session_1 = require("./session");
const storage_1 = require("../storage");
/**
 * Main wrapper class for managing multiple WhatsApp sessions
 */
class WacapWrapper {
    config;
    sessions = new Map();
    storageAdapter;
    constructor(config = {}) {
        this.config = {
            sessionsPath: config.sessionsPath || './sessions',
            storageAdapter: config.storageAdapter || 'sqlite',
            debug: config.debug || false,
            logger: config.logger || { level: 'warn' },
            prismaClient: config.prismaClient,
            autoDisplayQR: config.autoDisplayQR !== false,
            browser: config.browser || ['Wacap', 'Chrome', '1.0.0'],
            connectionTimeout: config.connectionTimeout || 60000,
            maxRetries: config.maxRetries || 5,
        };
        // Initialize storage adapter
        if (this.config.storageAdapter === 'prisma') {
            if (!this.config.prismaClient) {
                throw new Error('Prisma storage adapter requires prismaClient to be provided in config');
            }
            this.storageAdapter = new storage_1.PrismaStorageAdapter(this.config.prismaClient);
        }
        else {
            this.storageAdapter = new storage_1.SQLiteStorageAdapter(this.config.sessionsPath);
        }
    }
    /**
     * Initialize the wrapper
     */
    async init() {
        await this.storageAdapter.init();
    }
    /**
     * Start a new session or resume existing one
     */
    async sessionStart(sessionId, customConfig) {
        if (this.sessions.has(sessionId)) {
            const session = this.sessions.get(sessionId);
            if (session.isActive()) {
                throw new Error(`Session ${sessionId} is already active`);
            }
        }
        const sessionConfig = {
            ...this.config,
            ...customConfig,
        };
        const session = new session_1.Session(sessionId, sessionConfig, this.storageAdapter);
        this.sessions.set(sessionId, session);
        await session.start();
        return session;
    }
    /**
     * Stop a session
     */
    async sessionStop(sessionId) {
        const session = this.sessions.get(sessionId);
        if (!session) {
            throw new Error(`Session ${sessionId} not found`);
        }
        await session.stop();
        this.sessions.delete(sessionId);
    }
    /**
     * Find and return a session
     */
    findSession(sessionId) {
        return this.sessions.get(sessionId);
    }
    /**
     * Get all active sessions
     */
    getAllSessions() {
        return this.sessions;
    }
    /**
     * Get all session IDs
     */
    getSessionIds() {
        return Array.from(this.sessions.keys());
    }
    /**
     * Get session info
     */
    getSessionInfo(sessionId) {
        const session = this.sessions.get(sessionId);
        return session ? session.getInfo() : null;
    }
    /**
     * Check if session exists
     */
    hasSession(sessionId) {
        return this.sessions.has(sessionId);
    }
    /**
     * Delete session data from storage
     */
    async deleteSession(sessionId) {
        // Stop session if active
        if (this.sessions.has(sessionId)) {
            await this.sessionStop(sessionId);
        }
        // Delete from storage
        await this.storageAdapter.deleteSession(sessionId);
    }
    /**
     * Send a text message
     */
    async sendMessage(sessionId, jid, text, options) {
        const session = this.sessions.get(sessionId);
        if (!session) {
            throw new Error(`Session ${sessionId} not found`);
        }
        const socket = session.getSocket();
        if (!socket) {
            throw new Error(`Session ${sessionId} is not connected`);
        }
        const message = {
            text,
        };
        if (options?.quoted) {
            return await socket.sendMessage(jid, message, {
                quoted: options.quoted,
            });
        }
        if (options?.mentions) {
            return await socket.sendMessage(jid, {
                text,
                mentions: options.mentions,
            });
        }
        return await socket.sendMessage(jid, message);
    }
    /**
     * Send media (image, video, audio, document)
     */
    async sendMedia(sessionId, jid, media) {
        const session = this.sessions.get(sessionId);
        if (!session) {
            throw new Error(`Session ${sessionId} not found`);
        }
        const socket = session.getSocket();
        if (!socket) {
            throw new Error(`Session ${sessionId} is not connected`);
        }
        const content = {};
        // Determine media type from mimetype
        const mimetype = media.mimetype || '';
        if (mimetype.startsWith('image/')) {
            content.image = media.url || media.buffer;
            if (media.caption)
                content.caption = media.caption;
        }
        else if (mimetype.startsWith('video/')) {
            content.video = media.url || media.buffer;
            if (media.caption)
                content.caption = media.caption;
        }
        else if (mimetype.startsWith('audio/')) {
            content.audio = media.url || media.buffer;
            content.mimetype = mimetype;
        }
        else {
            content.document = media.url || media.buffer;
            content.mimetype = mimetype;
            if (media.fileName)
                content.fileName = media.fileName;
            if (media.caption)
                content.caption = media.caption;
        }
        return await socket.sendMessage(jid, content);
    }
    /**
     * Register event handler for a session
     */
    on(sessionId, event, handler) {
        const session = this.sessions.get(sessionId);
        if (!session) {
            throw new Error(`Session ${sessionId} not found`);
        }
        session.getEventManager().on(event, handler);
    }
    /**
     * Register one-time event handler for a session
     */
    once(sessionId, event, handler) {
        const session = this.sessions.get(sessionId);
        if (!session) {
            throw new Error(`Session ${sessionId} not found`);
        }
        session.getEventManager().once(event, handler);
    }
    /**
     * Get raw socket for advanced usage
     */
    getSocket(sessionId) {
        const session = this.sessions.get(sessionId);
        return session ? session.getSocket() : null;
    }
    /**
     * Cleanup all sessions and close storage
     */
    async destroy() {
        // Stop all sessions
        for (const [sessionId, session] of this.sessions) {
            await session.stop();
        }
        this.sessions.clear();
        // Close storage
        await this.storageAdapter.close();
    }
}
exports.WacapWrapper = WacapWrapper;
//# sourceMappingURL=wacap-wrapper.js.map