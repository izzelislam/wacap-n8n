"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrismaStorageAdapter = void 0;
/**
 * Prisma storage adapter for session data
 * Requires @prisma/client to be installed and configured by the user
 */
class PrismaStorageAdapter {
    prisma;
    constructor(prismaClient) {
        if (!prismaClient) {
            throw new Error('PrismaClient instance is required. Please provide it in the config.');
        }
        this.prisma = prismaClient;
    }
    async init() {
        // Prisma schema should be managed by the user
        // This assumes the user has created appropriate models
        // Example schema models needed:
        // - Session (id, sessionId, creds, createdAt, updatedAt)
        // - Message (id, sessionId, jid, message, timestamp, fromMe)
        // - Contact (id, sessionId, jid, name, notify, data)
        // - Chat (id, sessionId, jid, data, timestamp)
    }
    async saveSession(sessionId, creds) {
        await this.prisma.session.upsert({
            where: { sessionId },
            update: {
                creds: JSON.stringify(creds),
                updatedAt: new Date(),
            },
            create: {
                sessionId,
                creds: JSON.stringify(creds),
                createdAt: new Date(),
                updatedAt: new Date(),
            },
        });
    }
    async loadSession(sessionId) {
        const session = await this.prisma.session.findUnique({
            where: { sessionId },
        });
        return session ? JSON.parse(session.creds) : null;
    }
    async deleteSession(sessionId) {
        await this.prisma.session.delete({
            where: { sessionId },
        });
    }
    async hasSession(sessionId) {
        const count = await this.prisma.session.count({
            where: { sessionId },
        });
        return count > 0;
    }
    async saveMessage(sessionId, message) {
        const messageId = message.key.id;
        const jid = message.key.remoteJid;
        const timestamp = message.messageTimestamp;
        const fromMe = message.key.fromMe || false;
        await this.prisma.message.upsert({
            where: { id: messageId },
            update: {
                message: JSON.stringify(message),
                timestamp: new Date(timestamp * 1000),
            },
            create: {
                id: messageId,
                sessionId,
                jid,
                message: JSON.stringify(message),
                timestamp: new Date(timestamp * 1000),
                fromMe,
            },
        });
    }
    async getMessages(sessionId, jid, limit = 50) {
        const messages = await this.prisma.message.findMany({
            where: {
                sessionId,
                jid,
            },
            orderBy: {
                timestamp: 'desc',
            },
            take: limit,
        });
        return messages.map((msg) => JSON.parse(msg.message));
    }
    async saveContact(sessionId, contact) {
        const id = `${sessionId}:${contact.id}`;
        await this.prisma.contact.upsert({
            where: { id },
            update: {
                name: contact.name || null,
                notify: contact.notify || null,
                data: JSON.stringify(contact),
            },
            create: {
                id,
                sessionId,
                jid: contact.id,
                name: contact.name || null,
                notify: contact.notify || null,
                data: JSON.stringify(contact),
            },
        });
    }
    async getContacts(sessionId) {
        const contacts = await this.prisma.contact.findMany({
            where: { sessionId },
        });
        return contacts.map((contact) => JSON.parse(contact.data));
    }
    async saveChat(sessionId, chat) {
        const jid = chat.id;
        const id = `${sessionId}:${jid}`;
        await this.prisma.chat.upsert({
            where: { id },
            update: {
                data: JSON.stringify(chat),
                timestamp: new Date(),
            },
            create: {
                id,
                sessionId,
                jid,
                data: JSON.stringify(chat),
                timestamp: new Date(),
            },
        });
    }
    async getChats(sessionId) {
        const chats = await this.prisma.chat.findMany({
            where: { sessionId },
            orderBy: {
                timestamp: 'desc',
            },
        });
        return chats.map((chat) => JSON.parse(chat.data));
    }
    async close() {
        await this.prisma.$disconnect();
    }
}
exports.PrismaStorageAdapter = PrismaStorageAdapter;
//# sourceMappingURL=prisma-adapter.js.map