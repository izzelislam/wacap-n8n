"use strict";
/**
 * Utility helper functions
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatPhoneNumber = formatPhoneNumber;
exports.formatGroupJid = formatGroupJid;
exports.extractPhoneNumber = extractPhoneNumber;
exports.isGroup = isGroup;
exports.isStatus = isStatus;
exports.sleep = sleep;
exports.retryWithBackoff = retryWithBackoff;
exports.isValidSessionId = isValidSessionId;
/**
 * Format phone number to JID format
 * @param phoneNumber - Phone number with country code (e.g., "6281234567890")
 * @returns JID string (e.g., "6281234567890@s.whatsapp.net")
 */
function formatPhoneNumber(phoneNumber) {
    // Remove all non-numeric characters
    const cleaned = phoneNumber.replace(/\D/g, '');
    // Add WhatsApp suffix
    return `${cleaned}@s.whatsapp.net`;
}
/**
 * Format group JID
 * @param groupId - Group ID
 * @returns Group JID string
 */
function formatGroupJid(groupId) {
    if (groupId.includes('@g.us')) {
        return groupId;
    }
    return `${groupId}@g.us`;
}
/**
 * Extract phone number from JID
 * @param jid - JID string
 * @returns Phone number
 */
function extractPhoneNumber(jid) {
    return jid.split('@')[0];
}
/**
 * Check if JID is a group
 * @param jid - JID string
 * @returns true if group, false otherwise
 */
function isGroup(jid) {
    return jid.includes('@g.us');
}
/**
 * Check if JID is a status/broadcast
 * @param jid - JID string
 * @returns true if status, false otherwise
 */
function isStatus(jid) {
    return jid === 'status@broadcast';
}
/**
 * Delay/sleep function
 * @param ms - Milliseconds to delay
 */
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * Retry a function with exponential backoff
 * @param fn - Function to retry
 * @param maxRetries - Maximum number of retries
 * @param baseDelay - Base delay in milliseconds
 */
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
    let lastError;
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await fn();
        }
        catch (error) {
            lastError = error;
            if (i < maxRetries - 1) {
                const delay = baseDelay * Math.pow(2, i);
                await sleep(delay);
            }
        }
    }
    throw lastError || new Error('Max retries exceeded');
}
/**
 * Validate session ID
 * @param sessionId - Session ID to validate
 * @returns true if valid, false otherwise
 */
function isValidSessionId(sessionId) {
    // Session ID should be alphanumeric and can include hyphens, underscores
    return /^[a-zA-Z0-9_-]+$/.test(sessionId);
}
//# sourceMappingURL=helpers.js.map